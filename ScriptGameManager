using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
public class ScriptGameManager : MonoBehaviour
{
    public bool GamePaused;
    private bool PlayerRespawning;
    public float TimeFromReborn;
    private float CircleFillAmount;
    private float NumberOfColorTime;
    public int NumberOfGeneratedPlatforms;
    public int NumberOfScore;
    public int NumberOfAllScore;
    public int NumberOfLevel;
    private int NumberOfColor;
    public int NumberOfCircleTime;
    private int IntOfCurrentScore;
    private int IntOfBestScore;
    public Material[] MaterialOfPlatform;
    public Material[] MaterialOfPlayer;
    private int[] ScoreOfLevels = {10, 20, 50, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300, 320, 340, 360, 380, 400, 420, 440, 460, 480, 500, 520, 540, 560, 580, 600, 1000};
    public int[] ChanceToSpike = {100, 95, 95, 95, 90, 90, 90, 85, 85, 85, 80, 80, 80, 75, 75, 75, 70, 70, 70, 65, 65, 65, 60, 60, 60, 55, 55, 55, 50, 50, 40};
    public int[] ChanceToPlate = {100, 100, 100, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95};
    [SerializeField] private GameObject ScoreBoard;
    [SerializeField] private GameObject ScoreIndicatorBar;
    [SerializeField] private GameObject PlayerObject;
    [SerializeField] private GameObject PlatformObject;
    [SerializeField] private GameObject SceneCutManager;
    [SerializeField] private GameObject CircleProgressBar;
    [SerializeField] private GameObject ButtonOfPlayPause;
    [SerializeField] private GameObject AdButton;
    [SerializeField] private TextMeshProUGUI TextOfFrame;
    [SerializeField] private TextMeshProUGUI TextOfLevel;
    [SerializeField] private TextMeshProUGUI TextOfScore;
    [SerializeField] private TextMeshProUGUI TextOfCircleTitle;
    [SerializeField] private TextMeshProUGUI TextOfCircleTime;
    [SerializeField] private TextMeshProUGUI TextOfBestScore;
    [SerializeField] private TextMeshProUGUI TextOfCurrentScore;
    [SerializeField] private Sprite[] SpriteOfPlayAndPauseButton;
    [SerializeField] private Color[] ColorsOfMaterial0 = {new Color32(10, 0, 204, 255), new Color32(187, 0, 204, 255), new Color32(204, 0, 0, 255), new Color32(204, 100, 2, 255), new Color32(204, 177, 0, 255), new Color32(22, 204, 2, 255), new Color32(0, 204, 190, 255)};
    [SerializeField] private Color[] ColorsOfMaterial1 = {new Color32(9, 0, 179, 255), new Color32(164, 0, 179, 255), new Color32(179, 0, 0, 255), new Color32(179, 86, 1, 255), new Color32(179, 155, 0, 255), new Color32(20, 179, 1, 255), new Color32(0, 179, 168, 255)};
    [SerializeField] private Color[] ColorsOfMaterial2 = {new Color32(9, 0, 179, 255), new Color32(164, 0, 179, 255), new Color32(179, 0, 0, 255), new Color32(179, 86, 1, 255), new Color32(179, 155, 0, 255), new Color32(20, 179, 1, 255), new Color32(0, 179, 168, 255)};
    [SerializeField] private Color[] ColorsOfCamera = {new Color32(110, 107, 178, 255), new Color32(171, 0, 107, 178), new Color32(178, 107, 107, 255), new Color32(178, 140, 107, 255), new Color32(178, 167, 107, 255), new Color32(115, 178, 107, 255), new Color32(107, 178, 173, 255)};
    public void Start()
    {
        //UI beállítása.
        SceneCutManager.SetActive(true);
        //A változó színek beállítása.
        MaterialOfPlatform[0].color = ColorsOfMaterial0[5];
        MaterialOfPlatform[1].color = ColorsOfMaterial1[5];
        MaterialOfPlatform[2].color = ColorsOfMaterial1[5];
        Camera.main.backgroundColor = ColorsOfCamera[5];
    }
    public void Update()
    {
        Application.targetFrameRate = 60;
        QualitySettings.vSyncCount = 0;
        if (GamePaused == false)
        {
            //A Materialok és egyébb elemek szineinek állandó változtatása. 
            MaterialOfPlatform[0].color = Color.Lerp(MaterialOfPlatform[0].color, ColorsOfMaterial0[NumberOfColor], 0.2f * Time.deltaTime);
            MaterialOfPlatform[1].color = Color.Lerp(MaterialOfPlatform[1].color, ColorsOfMaterial1[NumberOfColor], 0.2f * Time.deltaTime);
            MaterialOfPlatform[2].color = Color.Lerp(MaterialOfPlatform[2].color, ColorsOfMaterial2[NumberOfColor], 0.2f * Time.deltaTime);
            Camera.main.backgroundColor = Color.Lerp(Camera.main.backgroundColor, ColorsOfCamera[NumberOfColor], 0.2f * Time.deltaTime);
            CircleProgressBar.GetComponent<Image>().color = Color.Lerp(MaterialOfPlatform[1].color, ColorsOfMaterial1[NumberOfColor], 0.2f * Time.deltaTime);
            CircleProgressBar.transform.GetChild(0).transform.GetChild(0).GetComponent<TextMeshProUGUI>().color = Color.Lerp(MaterialOfPlatform[1].color, ColorsOfMaterial1[NumberOfColor], 0.2f * Time.deltaTime);
            CircleProgressBar.transform.GetChild(0).transform.GetChild(1).GetComponent<TextMeshProUGUI>().color = Color.Lerp(MaterialOfPlatform[1].color, ColorsOfMaterial1[NumberOfColor], 0.2f * Time.deltaTime);
            ScoreIndicatorBar.GetComponent<Image>().color = Color.Lerp(MaterialOfPlatform[0].color, ColorsOfMaterial0[NumberOfColor], 0.2f * Time.deltaTime);
            //A Materialokon Lerp-pel megjelenített színek váltásáért felelős logika.
            NumberOfColorTime = Mathf.Lerp(NumberOfColorTime, 1f, 0.2f * Time.deltaTime);
            if (NumberOfColorTime > 0.9f)
            {
                NumberOfColor++;
                NumberOfColor = (NumberOfColor >= 6) ? 0 : NumberOfColor;
                NumberOfColorTime = 0;
            }
            //Az akutális FPS-t kiszámító és az eredményt megjelenítő részleg.
            float FloatOfFrame = 1 / Time.unscaledDeltaTime;
            TextOfFrame.text = Mathf.RoundToInt(FloatOfFrame) + "FPS";
            //A Player jelenlegi elért pontjaihoz tartozó számítások és megjelenítések.
            float PercentageOfLevel = (float)NumberOfScore / (float)ScoreOfLevels[NumberOfLevel] * 100;
            float PercentageOfPosition = ((PercentageOfLevel / 100) * 800) - 800;
            ScoreIndicatorBar.transform.localPosition = Vector4.MoveTowards(ScoreIndicatorBar.transform.localPosition, new Vector3(PercentageOfPosition, 0, 0), (100.125f + Vector3.Distance(ScoreIndicatorBar.transform.localPosition, new Vector3(PercentageOfPosition, 0, 0)))  * Time.deltaTime);
            TextOfLevel.text = NumberOfLevel.ToString();
            TextOfScore.text = NumberOfScore.ToString() + "/" + ScoreOfLevels[NumberOfLevel].ToString();
            //A szintlépés kiszámítása olyankor, amikor nincs maradék.
            if (NumberOfScore == ScoreOfLevels[NumberOfLevel])
            {
                NumberOfScore = 0;
                NumberOfLevel++;
            }
            //A szintlépés kiszámítása olyankor, amikor van maradék.
            if (NumberOfScore != ScoreOfLevels[NumberOfLevel] && NumberOfScore > ScoreOfLevels[NumberOfLevel])
            {
                NumberOfScore -= ScoreOfLevels[NumberOfLevel];
                NumberOfLevel++;
            }
            if (NumberOfScore < 0)
            {
                NumberOfScore = 0;
            }
            if (PlayerObject.GetComponent<ScriptPlayer>().PlayerAlive == false)
            {
                //Ebben az esetben a Player nincs életben.
                ButtonOfPlayPause.GetComponent<CanvasGroup>().alpha = 0;
                ButtonOfPlayPause.GetComponent<CanvasGroup>().interactable = false;
                ButtonOfPlayPause.GetComponent<CanvasGroup>().blocksRaycasts = false;
                AdButton.GetComponent<CanvasGroup>().alpha = 1;
                AdButton.GetComponent<CanvasGroup>().interactable = true;
                AdButton.GetComponent<CanvasGroup>().blocksRaycasts = true;
                if (PlayerRespawning)
                {
                    CircleProgressBar.GetComponent<Image>().fillAmount = Mathf.Lerp(CircleProgressBar.GetComponent<Image>().fillAmount, CircleFillAmount, 2.125f * Time.unscaledDeltaTime);
                }
                else
                {
                    //A töltés jelző megejelenítése.
                    if (CircleProgressBar.GetComponent<CanvasGroup>().alpha != 1f)
                    {
                        TextOfCircleTitle.text = "Respawning";
                        TextOfCircleTime.text = NumberOfCircleTime.ToString();
                        CircleProgressBar.GetComponent<CanvasGroup>().alpha = Mathf.Lerp(CircleProgressBar.GetComponent<CanvasGroup>().alpha, 1f, 5.125f * Time.unscaledDeltaTime);
                    }
                    //A töltés megkezdése.
                    if (CircleProgressBar.GetComponent<CanvasGroup>().alpha >= 0.9f)
                    {
                        CircleProgressBar.GetComponent<CanvasGroup>().alpha = 1f;
                        StartCoroutine(PlayerRespawn());
                        PlayerRespawning = true;
                    }
                }
            }
            else
            {
                //Ebben az esetben az Player életben van.
                ButtonOfPlayPause.GetComponent<CanvasGroup>().alpha = 1;
                ButtonOfPlayPause.GetComponent<CanvasGroup>().interactable = true;
                ButtonOfPlayPause.GetComponent<CanvasGroup>().blocksRaycasts = true;
                AdButton.GetComponent<CanvasGroup>().alpha = 0;
                AdButton.GetComponent<CanvasGroup>().interactable = false;
                AdButton.GetComponent<CanvasGroup>().blocksRaycasts = false;
                //Best és Current score számítása.
                if (IntOfBestScore < IntOfCurrentScore)
                {
                    IntOfBestScore = IntOfCurrentScore;
                }
                TextOfBestScore.text = IntOfBestScore.ToString();
                TextOfCurrentScore.text = IntOfCurrentScore.ToString();
                if (!PlayerRespawning)
                {
                    //A töltés jelző eltüntetése.
                    if (CircleProgressBar.GetComponent<CanvasGroup>().alpha != 0f)
                    {
                        CircleProgressBar.GetComponent<CanvasGroup>().alpha = Mathf.Lerp(CircleProgressBar.GetComponent<CanvasGroup>().alpha, 0f, 5.125f * Time.unscaledDeltaTime);
                    }
                    if (CircleProgressBar.GetComponent<CanvasGroup>().alpha <= 0.01f)
                    {
                        CircleProgressBar.GetComponent<CanvasGroup>().alpha = 0;
                    }
                    if (CircleProgressBar.GetComponent<CanvasGroup>().alpha == 0f && CircleProgressBar.GetComponent<Image>().fillAmount != 0f)
                    {
                        CircleFillAmount = 0f;
                        CircleProgressBar.GetComponent<Image>().fillAmount = 0f;
                    }
                }
            }
        }
    }
    IEnumerator PlayerRespawn()
    {
        if (PlayerObject.GetComponent<ScriptPlayer>().PlayerAlive == false)
        {
            if (NumberOfCircleTime != 3)
            {
                yield return new WaitForSeconds(1f);
            }
            else
            {
                yield return new WaitForSeconds(0.1f);
            }
            if (CircleProgressBar.GetComponent<Image>().fillAmount < 0.9f && PlayerRespawning == true)
            {
                CircleFillAmount += 0.4f;
                NumberOfCircleTime--;
                TextOfCircleTime.text = NumberOfCircleTime.ToString();
                IntOfCurrentScore = 0;
                StartCoroutine(PlayerRespawn());
            }
            if (CircleProgressBar.GetComponent<Image>().fillAmount >= 1f)
            {
                RebornOfPlayer();
                PlayerRespawning = false;
            }
        }
    }
    public void AddScore(int NumberOfEarnedScore)
    {
        NumberOfAllScore += NumberOfEarnedScore;
        NumberOfScore += NumberOfEarnedScore;
        IntOfCurrentScore++;
    }
    public void RebornOfPlayer()
    {
        GameObject FirstPlatform = Instantiate(PlatformObject, Vector3.zero, Quaternion.identity);
        PlayerObject.GetComponent<ScriptPlayer>().DieAndRebornOfPlayer();
        NumberOfCircleTime = 3;
        TimeFromReborn = 0;
    }
    public IEnumerator ButtonOfPlayAndPause()
    {
        switch (GamePaused)
        {
            case false:
                GamePaused = true;
                ButtonOfPlayPause.GetComponent<Image>().sprite = SpriteOfPlayAndPauseButton[1];
            break;
            case true:
                yield return new WaitForSeconds(1);
                GamePaused = false;
                ButtonOfPlayPause.GetComponent<Image>().sprite = SpriteOfPlayAndPauseButton[0];
            break;
        }
    }
}
