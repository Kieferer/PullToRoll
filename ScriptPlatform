using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ScriptPlatform : MonoBehaviour
{
    public bool PlayerReached;
    public bool PlatfromGenerated;
    public bool PlatfromSpike;
    public bool PlatformPlate;
    public bool NextPlatformSpike;
    public int NumberSidesOfPlatform;
    private bool[] SidesOfPlatform = {false, false, false};
    private float FloatOfSpikeY;
    private GameObject PlayerObject;
    private GameObject GameManager;
    private GameObject PlatformParent;
    [SerializeField] private GameObject PlatformPrefab;
    [SerializeField] private GameObject SpikeOfThisPlatform;
    [SerializeField] private GameObject PlateOfThisPlatform;
    public void Awake()
    {
        if (!PlayerObject || !GameManager)
        {
            PlayerObject = GameObject.FindWithTag("Player");
            GameManager = GameObject.FindWithTag("GameManager");
        }
    }
    public void Start()
    {
        //Platform tulajdonságainak beállítása.
        GameManager.GetComponent<ScriptGameManager>().NumberOfGeneratedPlatforms++;
        this.gameObject.name = ("[Platform][" + GameManager.GetComponent<ScriptGameManager>().NumberOfGeneratedPlatforms + "]"); 
        if (SpikeOfThisPlatform != null && PlateOfThisPlatform != null)
        {
            SpikeOfThisPlatform.GetComponent<MeshRenderer>().material = GameObject.FindWithTag("GameManager").GetComponent<ScriptGameManager>().MaterialOfPlatform[2];
            if (PlatfromSpike == false)
            {
                FloatOfSpikeY = -5f;
                SpikeOfThisPlatform.transform.localPosition = new Vector3(SpikeOfThisPlatform.transform.localPosition.x, -5f, SpikeOfThisPlatform.transform.localPosition.z);
                if (PlatformPlate == true)
                {
                    PlateOfThisPlatform.transform.localPosition = new Vector3(PlateOfThisPlatform.transform.localPosition.x, 0.6f, PlateOfThisPlatform.transform.localPosition.z);
                }
            }
            else
            {
                FloatOfSpikeY = 0f;
                SpikeOfThisPlatform.transform.localPosition = new Vector3(SpikeOfThisPlatform.transform.localPosition.x, 0f, SpikeOfThisPlatform.transform.localPosition.z);
                PlateOfThisPlatform.transform.localPosition = new Vector3(PlateOfThisPlatform.transform.localPosition.x, -4f, PlateOfThisPlatform.transform.localPosition.z);
            }
        }
        //PlatformSpike generálása esély alapján a jelenlegi szinttől függően.
        if (Random.Range(0, 100) > GameManager.GetComponent<ScriptGameManager>().ChanceToSpike[GameManager.GetComponent<ScriptGameManager>().NumberOfLevel])
        {
            NextPlatformSpike = true;
        }
        else
        {
            NextPlatformSpike = false;
        }
        //PlatformSpike generálása esély alapján a jelenlegi szinttől függően.
        if (PlatfromSpike == false && transform.childCount > 2)
        {
            if (Random.Range(0, 100) > GameManager.GetComponent<ScriptGameManager>().ChanceToPlate[GameManager.GetComponent<ScriptGameManager>().NumberOfLevel])
            {
                transform.GetChild(2).transform.localPosition = new Vector3(0f, 0.6f, 0f);
                PlatformPlate = true;
            }
            else
            {
                transform.GetChild(2).transform.localPosition = new Vector3(0f, -6f, 0f);
                PlatformPlate = false;
            }
        }
        //Platform Material-jainak beállítása.
        GetComponent<MeshRenderer>().material = GameObject.FindWithTag("GameManager").GetComponent<ScriptGameManager>().MaterialOfPlatform[0];
        transform.GetChild(0).GetComponent<MeshRenderer>().material = GameObject.FindWithTag("GameManager").GetComponent<ScriptGameManager>().MaterialOfPlatform[1];
        //A Platform oldalainak ellenörzése és az ahhoz szükséges változók.
        Vector3[] VectorsOfSides = {Vector3.forward, Vector3.right, Vector3.back};
        for (int NumberOfSide = 0; NumberOfSide < VectorsOfSides.Length; NumberOfSide++)
        {
            if (Physics.Raycast(transform.position, VectorsOfSides[NumberOfSide], 2f))
            {
                SidesOfPlatform[NumberOfSide] = true;
            }
            if (NumberOfSide == 0 || NumberOfSide == 2)
            {
                if (Physics.Raycast(transform.position + VectorsOfSides[NumberOfSide], Vector3.left, 2f))
                {
                    SidesOfPlatform[NumberOfSide] = true;
                }
            }
        }
    }
    public void Update()
    {
        if (GameManager.GetComponent<ScriptGameManager>().GamePaused == false)
        {
            if (PlayerObject)
            {
                //A Platform legenerálása utáni helyre mozgatása.
                if (transform.position.y != 0 && !PlatfromGenerated && PlayerObject.GetComponent<ScriptPlayer>().PlayerAlive)
                {
                    transform.position = Vector3.MoveTowards(transform.position, new Vector3(transform.position.x, 0, transform.position.z), ((4.125f + Mathf.Abs(transform.position.y) * 5) * Time.unscaledDeltaTime));
                }
                //Az új Platform legenerálása/eltüntetése és az ahhoz szükséges számítások.
                float DistanceOfPlayer = Vector3.Distance(transform.position, PlayerObject.transform.position);
                if (transform.position.y == 0 && DistanceOfPlayer < 10f && !PlatfromGenerated)
                {
                    //Ha a közelsége kevesebb mint 2.8f és még nem generált korábban Platformot akkor megteszi.
                    NumberSidesOfPlatform = Random.Range(0, 3);
                    if (this.SidesOfPlatform[NumberSidesOfPlatform] == false)
                    {
                        GeneratePlatform(NumberSidesOfPlatform);
                        PlatfromGenerated = true;
                    }
                }
                if ((DistanceOfPlayer > 3 && PlatfromGenerated && PlayerReached && !PlatformParent) || !PlayerObject.GetComponent<ScriptPlayer>().PlayerAlive)
                {
                    if (transform.position.y != -20)
                    {
                        transform.position = Vector3.MoveTowards(transform.position, new Vector3(transform.position.x, -20, transform.position.z), ((Vector3.Distance(transform.position, PlayerObject.transform.position) / 100) + (4.125f + Mathf.Abs(transform.position.y) * 2) * Time.unscaledDeltaTime));
                    }
                    else
                    {
                        Destroy(this.gameObject);
                    }        
                }
                //A PlatformSpike vezérlésért felelős logika.
                if (PlatfromSpike == true && transform.position.y == 0)
                {
                    if (transform.position == new Vector3(PlayerObject.transform.position.x, transform.position.y, PlayerObject.transform.position.z))
                    {
                        SpikeOfThisPlatform.transform.localPosition = new Vector3(SpikeOfThisPlatform.transform.localPosition.x, -5f, SpikeOfThisPlatform.transform.localPosition.z);
                        FloatOfSpikeY = -5f;
                    }
                    else
                    {
                        if (SpikeOfThisPlatform.transform.localPosition.y > -1f)
                        {
                            FloatOfSpikeY = -5f;
                        }
                        if (SpikeOfThisPlatform.transform.localPosition.y < -4.7f)
                        {
                            FloatOfSpikeY = 0f;
                        }
                        SpikeOfThisPlatform.transform.localPosition = Vector3.MoveTowards(SpikeOfThisPlatform.transform.localPosition, new Vector3(SpikeOfThisPlatform.transform.localPosition.x, FloatOfSpikeY, SpikeOfThisPlatform.transform.localPosition.z), ((2.125f + Mathf.Abs(transform.position.y) * 5) * Time.unscaledDeltaTime));
                    }
                }
            }
        }
    }
    public void GeneratePlatform(int NumberOfSides)
    {
        Vector3 NextTargetedPosition;
        switch (NumberOfSides)
        {
            //Ebben az esetben a Platformot a jelenlegitől jobbra fogja generálni.
            case 0:
                NextTargetedPosition = (new Vector3(transform.position.x, -20, transform.position.z) + Vector3.forward);
                GameObject Platform0 = Instantiate(PlatformPrefab, NextTargetedPosition, Quaternion.identity);
                Platform0.GetComponent<ScriptPlatform>().PlatformParent = this.gameObject;
                Platform0.GetComponent<ScriptPlatform>().PlatfromSpike = NextPlatformSpike;
            break;
            //Ebben az esetben a Platformot a jelenlegitől előre fogja generálni.
            case 1:
                NextTargetedPosition = (new Vector3(transform.position.x, -20, transform.position.z) + Vector3.right);
                GameObject Platform1 = Instantiate(PlatformPrefab, NextTargetedPosition, Quaternion.identity);
                Platform1.GetComponent<ScriptPlatform>().PlatformParent = this.gameObject;
                Platform1.GetComponent<ScriptPlatform>().PlatfromSpike = NextPlatformSpike;
            break;
            //Ebben az esetben a Platformot a jelenlegitől balra fogja generálni.
            case 2:
                NextTargetedPosition = (new Vector3(transform.position.x, -20, transform.position.z) + Vector3.back);
                GameObject Platform2 = Instantiate(PlatformPrefab, NextTargetedPosition, Quaternion.identity);
                Platform2.GetComponent<ScriptPlatform>().PlatformParent = this.gameObject;
                Platform2.GetComponent<ScriptPlatform>().PlatfromSpike = NextPlatformSpike;
            break;
        }
    }
}
