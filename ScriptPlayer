using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ScriptPlayer : MonoBehaviour
{
    public bool PlayerAlive;
    private bool StillMoving;
    public GameObject GameManager;
    public GameObject PlayerObjectBroken;
    private Vector2 PositionOfFirstTouch;
    private Vector2 PositionOfLastTouch;
    private Vector3[] DirectionsOfRoll = {Vector3.zero, Vector3.zero, Vector3.zero, Vector3.zero};
    public void Start()
    {
        DirectionsOfRoll[0] = (new Vector3(-GetComponent<BoxCollider>().bounds.size.x / 2, -GetComponent<BoxCollider>().bounds.size.y / 2, 0));
        DirectionsOfRoll[1] = (new Vector3(GetComponent<BoxCollider>().bounds.size.x / 2, -GetComponent<BoxCollider>().bounds.size.y / 2, 0));
        DirectionsOfRoll[2] = (new Vector3(0, -GetComponent<BoxCollider>().bounds.size.y / 2, -GetComponent<BoxCollider>().bounds.size.z / 2));
        DirectionsOfRoll[3] = (new Vector3(0, -GetComponent<BoxCollider>().bounds.size.y / 2, GetComponent<BoxCollider>().bounds.size.z / 2));
    }
    public void Update()
    {
        if (!StillMoving && PlayerAlive == true)
        {
            //A PlayerObject irányítása.
            if (Input.touchCount >= 1 && Input.GetTouch(0).phase == TouchPhase.Began)
            {
                PositionOfFirstTouch = Input.GetTouch(0).position;
            }
            if (Input.touchCount > 0 && Input.GetTouch(0).phase == TouchPhase.Ended)
            {
                PositionOfLastTouch = Input.GetTouch(0).position;
                float DifferenceOfX = (PositionOfFirstTouch.x - PositionOfLastTouch.x);
                float DifferenceOfY = (PositionOfFirstTouch.y - PositionOfLastTouch.y);
                if (Mathf.Abs(DifferenceOfX) > Mathf.Abs(DifferenceOfY) && Mathf.Abs(DifferenceOfX) != Mathf.Abs(DifferenceOfY))
                {
                    if (DifferenceOfX > 0)
                    {
                        //Ebben az esteben a PlayerObject jobb oldalra fog forogni.
                        StartCoroutine(MovePlayerObject(DirectionsOfRoll[0]));
                    }
                    if (DifferenceOfX < 0)
                    {
                        //Ebben az esteben a PlayerObject bal oldalra fog forogni.
                        StartCoroutine(MovePlayerObject(DirectionsOfRoll[1]));
                    }
                }
                if (Mathf.Abs(DifferenceOfX) < Mathf.Abs(DifferenceOfY) && Mathf.Abs(DifferenceOfX) != Mathf.Abs(DifferenceOfY))
                {
                    if (DifferenceOfY > 0)
                    {
                        //Ebben az esteben a PlayerObject felfele fog forogni.
                        StartCoroutine(MovePlayerObject(DirectionsOfRoll[2]));
                    }
                    if (DifferenceOfY < 0)
                    {
                        //Ebben az esteben a PlayerObject lefele fog forogni.
                        StartCoroutine(MovePlayerObject(DirectionsOfRoll[3]));
                    }
                }
            }
        }
    }
    public void OnTriggerEnter(Collider collider)
    {
        if (collider.gameObject.tag == "PlatformSpike" && PlayerAlive)
        {
            DieAndRebornOfPlayer();
        }
    }
    public void InspectorRay()
    {
        //A PlayerObject megállapítja, hogyha Platformra érkezett, akkor milyenre.
        if (!Physics.Raycast(transform.position, Vector3.down, out RaycastHit Platform, 4f))
        {
            DieAndRebornOfPlayer();
        }
        else
        {
            if (PlayerAlive)
            {
                if (Platform.transform.GetComponent<ScriptPlatform>().PlayerReached == false && Platform.transform.GetComponent<ScriptPlatform>().PlatfromSpike == false && Platform.transform.GetComponent<ScriptPlatform>().PlatfromGenerated == true)
                {
                    //1 pont
                    Platform.transform.GetComponent<ScriptPlatform>().PlayerReached = true;
                }
                if (Platform.transform.GetComponent<ScriptPlatform>().PlayerReached == false && Platform.transform.GetComponent<ScriptPlatform>().PlatfromSpike == true && Platform.transform.GetComponent<ScriptPlatform>().PlatfromGenerated == true)
                {
                    //2 pont
                    Platform.transform.GetComponent<ScriptPlatform>().PlayerReached = true;
                }
                if (Platform.transform.GetComponent<ScriptPlatform>().PlayerReached == false && Platform.transform.GetComponent<ScriptPlatform>().PlatfromSpike == false && Platform.transform.GetComponent<ScriptPlatform>().PlatfromGenerated == true)
                {
                    //3 pont
                    Platform.transform.GetComponent<ScriptPlatform>().PlayerReached = true;
                }
                if (Platform.transform.GetComponent<ScriptPlatform>().PlayerReached == false && Platform.transform.GetComponent<ScriptPlatform>().PlatfromSpike == true && Platform.transform.GetComponent<ScriptPlatform>().PlatfromGenerated == true)
                {
                    //4 pont
                    Platform.transform.GetComponent<ScriptPlatform>().PlayerReached = true;
                }
            }
        }
    }
    public void DieAndRebornOfPlayer()
    {
        switch (PlayerAlive)
        {
            case true:
                //Ebben az esetben a PlayerObject elpusztul.
                PlayerAlive = false;
                GetComponent<BoxCollider>().enabled = false;
                GetComponent<MeshRenderer>().enabled = false;
                GameObject PlayerObjectDead = Instantiate(PlayerObjectBroken, transform.position, Quaternion.identity);
                Destroy(PlayerObjectDead, 10);
            break;

            case false:
                //Ebben az esetben a PlayerObject újászület.
                transform.position = new Vector3(0, 0.62f, 0);
                GetComponent<BoxCollider>().enabled = true;
                GetComponent<MeshRenderer>().enabled = true;
                PlayerAlive = true;
            break;
        }
    }
    public IEnumerator MovePlayerObject(Vector3 DirectionForRoll)
    {
        StillMoving = true;
        float RotationOfObject = 0;
        Vector3 CenterOfObject = transform.position + DirectionForRoll;
        Vector3 AxisOfObject = Vector3.Cross(Vector3.up, DirectionForRoll).normalized;
        while (RotationOfObject < 90f)
        {
            transform.RotateAround(CenterOfObject, AxisOfObject, 400.125f * Time.deltaTime);
            RotationOfObject += (400.125f * Time.deltaTime);
            yield return null;
        }
        transform.RotateAround(CenterOfObject, AxisOfObject, 90 - RotationOfObject);
        StillMoving = false;
        InspectorRay();
    }
}
